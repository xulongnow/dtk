<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  <title>在线答题卡丨申论格子纸语文作文纸</title>
  <style>
    /* 新增错误提示样式 */
    .error-message {
      color: #d9534f;
      background-color: #f2dede;
      border: 1px solid #ebccd1;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      display: none;
    }
    
    /* 打印页面全局边距，保障打印内容不裁切 */
    @page { margin: 10mm; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
    }
    .container {
      text-align: center;
      width: 100%;
      margin-top: 10px;
    }
    .guide {
      display: block;
      margin-top: 20px;
      margin-bottom: 10px;
      font-size: 16px;
    }
    @media print {
      /* 打印时隐藏不相关元素 */
      .guide, .editable-div, .buttons, .adjust-buttons, .error-message {
        display: none !important;
      }
      body {
        width: 100%;
        height: auto;
        /* 内部增加安全边距，兼容无@page情形 */
        padding: 10mm;
      }
      .grid-container {
        width: 100%;
        grid-template-columns: repeat(25, 1fr);
        grid-template-rows: auto;
      }
      .grid-item {
        width: auto;
        height: auto;
        padding: 1px;
        font-size: 17px;
      }
      .container { margin-top: 0; }
      
      /* 修复打印时标注被裁剪问题 */
  .grid-item:nth-child(100n)::after {
    right: 0;
    font-size: 8px; /* 进一步缩小打印字体 */
    bottom: -10px;
    transform: translateX(100%);
    padding-right: 1px;
    max-width: 18px; /* 更严格的打印限制 */
  }
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(25, auto);
      column-gap: 0;
      row-gap: 8px;
      justify-content: center;
      margin-top: 20px;
    }
    .grid-item {
      border-top: 1px solid red;
      border-left: 1px solid red;
      border-bottom: 1px solid red;
      padding: 5px;
      text-align: center;
      font-size: 20px;
      width: 1.1em;
      height: 1.1em;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer; /* 添加指针样式 */
    }
    .grid-item:hover {
      background-color: #f0f8ff; /* 添加悬停效果 */
    }
    .grid-item:nth-child(25n) { border-right: 1px solid red; }
    .grid-item:nth-child(100n) {
      border-right: 2px solid red;
      position: relative;
    }
/* 修改后（普通模式） */
.grid-item:nth-child(100n)::after {
  content: attr(data-index);
  color: red;
  font-size: 10px; /* 缩小字体避免溢出 */
  font-weight: normal;
  position: absolute;
  right: 0; /* 对齐格子右边线 */
  bottom: -12px; /* 下移避免重叠 */
  transform: translateX(100%); /* 数字整体右移 */
  padding-right: 2px; /* 添加微调间距 */
  text-align: right; /* 文本右对齐 */
  width: max-content; /* 自适应宽度 */
  max-width: 22px; /* 限制最大宽度 */
  overflow: hidden; /* 防溢出 */
}
    /* 替换textarea为可编辑div */
    .editable-div {
      width: 40%;
      height: 250px;
      margin-bottom: 10px;
      font-size: 18px;
      border: 1px solid #ccc;
      padding: 5px;
      white-space: pre-wrap; /* 保留空白和换行 */
      overflow: auto;
      text-align: left; /* 确保文本左对齐 */
    }
    .editable-div .directive {
      color: blue; /* +N+指令显示为蓝色 */
    }
    .buttons {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .buttons button { margin: 0 7px; }
    
    /* 新增：调整导出和导入按钮间距 */
    .buttons button:nth-child(8) {
      margin-right: 1px; /* 导出TXT按钮右边距设为1px */
    }
    .buttons button:nth-child(9) {
      margin-left: 1px; /* 导入按钮左边距设为1px */
    }
    
    .count-display {
      margin-left: 10px;
      font-size: 14px;
      font-weight: bold;
      padding: 5px;
      border: 1px solid #000;
      border-radius: 5px;
      background-color: #f0f0f0;
    }
    .input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .size-buttons {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }
    .size-buttons button { margin: 0 5px; }
    
    /* 移动端适配 */
    @media (max-width: 768px) {
      .editable-div { width: 90%; }
      .grid-item { font-size: 16px; }
      .buttons { flex-wrap: wrap; }
      .buttons button { margin: 5px; }
      
      /* 移动端导出和导入按钮间距调整 */
      .buttons button:nth-child(8) {
        margin-right: 1px;
      }
      .buttons button:nth-child(9) {
        margin-left: 1px;
      }
    }

    .editable-div {
      width: 40%;
      height: 250px;
      margin-bottom: 10px;
      font-size: 18px;
      border: 1px solid #ccc;
      padding: 5px;
      white-space: pre-wrap; /* 保留空白和换行 */
      overflow: auto;
      text-align: left; /* 确保文本左对齐 */
      resize: both; /* 添加此行以启用拖动调整大小功能 */
    }

    /* 新增：自动输入按钮样式 */
    .auto-on {
      background-color: #4CAF50; /* 绿色表示开启 */
      color: white;
    }
    .auto-off {
      background-color: #f44336; /* 红色表示关闭 */
      color: white;
    }
    
    /* 新增：光标高亮样式 */
    .cursor-highlight {
      background-color: rgba(255, 255, 0, 0.5);
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      50% { background-color: rgba(255, 255, 0, 0.2); }
    }
  </style>
</head>
<body>
  <div class="guide">在线答题卡丨仅用于考试答题模拟，无在线缓存功能，请及时保存</div>
  <div class="guide">【回车键】换行（自动空2格）、【空格键】空1格、【Tab键】空2格、【+N+】空N格</div>
  <div class="error-message" id="error-message"></div>
  <div class="container">
    <div class="input-container">
      <div class="size-buttons adjust-buttons">
        <button onclick="resetTextarea()">复原</button>
        <button onclick="adjustTextarea('wide')">宽</button>
        <button onclick="adjustTextarea('narrow')">窄</button>
        <button onclick="adjustTextarea('tall')">高</button>
        <button onclick="adjustTextarea('short')">低</button>
      </div>
      <!-- 替换textarea为可编辑div -->
      <div id="input-text" class="editable-div" contenteditable="true" oninput="distributeTextWithDelay()" onkeydown="handleKeyDown(event)"></div>
    </div>
    <div class="buttons">
      <button onclick="clearPlusN()">清除+N+</button>
      <button onclick="clearNewLines()">清除换行</button>
      <button onclick="clearSpaces()">清除空格</button>
      <button onclick="clearInput()">清空</button>
      <button onclick="undo()">撤销</button>
      <button id="toggle-auto-input" class="auto-on" onclick="toggleAutoInput()">自动输入·开</button>
      <button onclick="distributeText()">填入答题纸</button>
      <button onclick="downloadText()">导出TXT</button>
      <button onclick="importText()">导入</button>
      <button onclick="window.print()">打印</button>
      <div class="count-display" id="count-display">统计字数: 0</div>
    </div>
    <div class="grid-container" id="grid-container"></div>
  </div>
  <script>
    const GRID_COLUMNS_PER_ROW = 25;
    let updateTimeout;
    let autoInputEnabled = true;
    const initialWidth = '40%';
    const initialHeight = '250px';
    
    // 新增：撤销历史记录
    const undoHistory = [];
    const MAX_UNDO_STEPS = 10;

    // 新增：错误消息显示函数
    function showError(message) {
      const errorElement = document.getElementById('error-message');
      errorElement.innerText = message;
      errorElement.style.display = 'block';
      
      // 5秒后自动隐藏错误信息
      setTimeout(() => {
        errorElement.style.display = 'none';
      }, 5000);
    }

    // 新增：保存和恢复光标位置的函数
    function saveCaretPosition(container) {
      const selection = window.getSelection();
      if (selection.rangeCount === 0) return null;
      
      const range = selection.getRangeAt(0);
      const preRange = document.createRange();
      preRange.selectNodeContents(container);
      preRange.setEnd(range.startContainer, range.startOffset);
      
      return {
        start: preRange.toString().length,
        range: range
      };
    }

    function restoreCaretPosition(container, pos) {
      if (pos === null) return;
      
      const textNodes = getTextNodes(container);
      let total = 0;
      
      for (let node of textNodes) {
        const length = node.nodeValue.length;
        if (pos.start <= total + length) {
          const range = document.createRange();
          range.setStart(node, pos.start - total);
          range.collapse(true);
          
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
          container.focus();
          return;
        }
        total += length;
      }
      
      // 如果位置超出，放在最后
      if (textNodes.length > 0) {
        const lastNode = textNodes[textNodes.length - 1];
        const range = document.createRange();
        range.setStart(lastNode, lastNode.nodeValue.length);
        range.collapse(true);
        
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        container.focus();
      }
    }

    function getTextNodes(container) {
      const textNodes = [];
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
      
      while (walker.nextNode()) {
        textNodes.push(walker.currentNode);
      }
      
      return textNodes;
    }

    // 修改后：高亮指令时保存和恢复光标位置
    function highlightDirectives() {
      const inputTextDiv = document.getElementById('input-text');
      const text = inputTextDiv.innerText;
      
      // 保存光标位置
      const caretPos = saveCaretPosition(inputTextDiv);
      
      // 使用正则表达式匹配+N+指令
      const regex = /(\+\d+\+)/g;
      const newHTML = text.replace(regex, '<span class="directive">$1</span>');
      
      inputTextDiv.innerHTML = newHTML;
      
      // 恢复光标位置
      restoreCaretPosition(inputTextDiv, caretPos);
    }

    function insertText(text) {
      try {
        const inputTextDiv = document.getElementById('input-text');
        const selection = window.getSelection();
        
        if (selection.rangeCount) {
          const range = selection.getRangeAt(0);
          range.deleteContents();
          
          const textNode = document.createTextNode(text);
          range.insertNode(textNode);
          
          // 移动光标到插入位置之后
          range.setStartAfter(textNode);
          range.setEndAfter(textNode);
          selection.removeAllRanges();
          selection.addRange(range);
        }
        
        distributeTextWithDelay();
      } catch (error) {
        showError(`插入文本失败: ${error.message}`);
      }
    }

    function handleKeyDown(event) {
      try {
        if (event.key === 'Enter') {
          event.preventDefault();
          // 修改：回车时自动添加换行符和+2+指令
          insertText('\n+2+');
        } else if (event.key === 'Tab') {
          event.preventDefault();
          insertText('+2+');
        } else if (event.key === ' ') {
          event.preventDefault();
          insertText(' ');
        }
      } catch (error) {
        showError(`按键处理错误: ${error.message}`);
      }
    }

    function clearNewLines() {
      try {
        const inputTextDiv = document.getElementById('input-text');
        
        // 保存光标位置
        const caretPos = saveCaretPosition(inputTextDiv);
        
        inputTextDiv.innerText = inputTextDiv.innerText.replace(/\n/g, '');
        highlightDirectives();
        distributeTextWithDelay();
        
        // 恢复光标位置
        restoreCaretPosition(inputTextDiv, caretPos);
      } catch (error) {
        showError(`清除换行失败: ${error.message}`);
      }
    }

    function clearSpaces() {
      try {
        const inputTextDiv = document.getElementById('input-text');
        
        // 保存光标位置
        const caretPos = saveCaretPosition(inputTextDiv);
        
        inputTextDiv.innerText = inputTextDiv.innerText.replace(/ /g, '');
        highlightDirectives();
        distributeTextWithDelay();
        
        // 恢复光标位置
        restoreCaretPosition(inputTextDiv, caretPos);
      } catch (error) {
        showError(`清除空格失败: ${error.message}`);
      }
    }

    function clearInput() {
      try {
        const inputTextDiv = document.getElementById('input-text');
        
        // 保存光标位置
        const caretPos = saveCaretPosition(inputTextDiv);
        
        inputTextDiv.innerText = '';
        highlightDirectives();
        distributeTextWithDelay();
        
        // 恢复光标位置（虽然内容为空，但保持光标在开头）
        restoreCaretPosition(inputTextDiv, caretPos);
      } catch (error) {
        showError(`清空输入失败: ${error.message}`);
      }
    }

    function clearPlusN() {
      try {
        const inputTextDiv = document.getElementById('input-text');
        
        // 保存光标位置
        const caretPos = saveCaretPosition(inputTextDiv);
        
        inputTextDiv.innerText = inputTextDiv.innerText.replace(/\+\d+\+/g, '');
        highlightDirectives();
        distributeTextWithDelay();
        
        // 恢复光标位置
        restoreCaretPosition(inputTextDiv, caretPos);
      } catch (error) {
        showError(`清除+N+指令失败: ${error.message}`);
      }
    }
    
    function distributeTextWithDelay() {
      clearTimeout(updateTimeout);
      if (!autoInputEnabled) return;
      
      // 保存光标位置
      const inputTextDiv = document.getElementById('input-text');
      const caretPos = saveCaretPosition(inputTextDiv);
      
      // 性能优化：减少DOM操作频率
      updateTimeout = setTimeout(() => {
        try {
          distributeText();
          saveToLocalStorage();
          highlightDirectives(); // 更新高亮
        } catch (error) {
          showError(`文本处理失败: ${error.message}`);
        } finally {
          // 恢复光标位置
          restoreCaretPosition(inputTextDiv, caretPos);
        }
      }, 300); // 延迟时间从500ms减少到300ms
    }

    function saveToLocalStorage() {
      try {
        const text = document.getElementById('input-text').innerText;
        localStorage.setItem('savedText', text);
      } catch (error) {
        showError(`保存到本地存储失败: ${error.message}`);
      }
    }

    // 性能优化：拆分大型函数
    function calculateEffectiveLength(text) {
      let effectiveLength = 0;
      
      for (let i = 0; i < text.length; i++) {
        if (text[i] === '\n') {
          effectiveLength += GRID_COLUMNS_PER_ROW - (effectiveLength % GRID_COLUMNS_PER_ROW);
        } else if (text[i] === '+') {
          if (/\d/.test(text[i + 1])) {
            let j = i + 1;
            let validDirective = true;
            while (j < text.length && text[j] !== '+') {
              if (!/\d/.test(text[j])) {
                validDirective = false;
                break;
              }
              j++;
            }
            if (validDirective && j < text.length && text[j] === '+') {
              effectiveLength += parseInt(text.substring(i + 1, j), 10);
              i = j;
            } else {
              effectiveLength++;
            }
          } else {
            effectiveLength++;
          }
        } else {
          effectiveLength++;
        }
      }
      
      return effectiveLength;
    }

    function createGridItems(numItems) {
      const fragment = document.createDocumentFragment();
      
      for (let i = 0; i < numItems; i++) {
        const gridItem = document.createElement('div');
        gridItem.className = 'grid-item';
        if ((i + 1) % 100 === 0) {
          gridItem.setAttribute('data-index', i + 1);
        }
        fragment.appendChild(gridItem);
      }
      
      return fragment;
    }

    function fillGridItems(text, gridItems) {
      let gridIndex = 0;
      let i = 0;
      
      while (i < text.length && gridIndex < gridItems.length) {
        if (text[i] === '\n') {
          if (gridIndex % GRID_COLUMNS_PER_ROW !== 0) {
            gridIndex = Math.floor(gridIndex / GRID_COLUMNS_PER_ROW) * GRID_COLUMNS_PER_ROW + GRID_COLUMNS_PER_ROW;
          }
          i++;
        } else if (/[a-zA-Z0-9]/.test(text[i]) && /[a-zA-Z0-9.]/.test(text[i + 1])) {
          gridItems[gridIndex].innerText = text.substring(i, i + 2);
          gridItems[gridIndex].dataset.sourceIndex = i; // 记录原始位置
          gridIndex++;
          i += 2;
        } else if (text[i] === '+') {
          if (/\d/.test(text[i + 1])) {
            let j = i + 1;
            let validDirective = true;
            while (j < text.length && text[j] !== '+') {
              if (!/\d/.test(text[j])) {
                validDirective = false;
                break;
              }
              j++;
            }
            if (validDirective && j < text.length && text[j] === '+') {
              const numSpaces = parseInt(text.substring(i + 1, j), 10);
              for (let k = 0; k < numSpaces && gridIndex < gridItems.length; k++) {
                gridItems[gridIndex].innerText = ' ';
                gridItems[gridIndex].dataset.sourceIndex = i; // 记录原始位置
                gridIndex++;
              }
              i = j + 1;
            } else {
              gridItems[gridIndex].innerText = text[i];
              gridItems[gridIndex].dataset.sourceIndex = i; // 记录原始位置
              gridIndex++;
              i++;
            }
          } else {
            gridItems[gridIndex].innerText = text[i];
            gridItems[gridIndex].dataset.sourceIndex = i; // 记录原始位置
            gridIndex++;
            i++;
          }
        } else {
          // 行首标点避头，排除省略号和破折号
          if (gridIndex % GRID_COLUMNS_PER_ROW === 0 
              && /[，。！？；：’”、）》,.!?;:]/.test(text[i]) 
              && text[i] !== '…' && text[i] !== '—') {
            gridItems[gridIndex - 1].innerText += text[i];
            // 对于合并的字符，不需要更新位置索引
          }
          // 引号后标点合并，同样排除省略号和破折号
          else if (gridIndex > 0 
              && /[》”"]/.test(gridItems[gridIndex - 1].innerText) 
              && /[、，。：；？！,.?!;:]/.test(text[i]) 
              && text[i] !== '…' && text[i] !== '—') {
            gridItems[gridIndex - 1].innerText += text[i];
            // 对于合并的字符，不需要更新位置索引
          }
          else {
            gridItems[gridIndex].innerText = text[i];
            gridItems[gridIndex].dataset.sourceIndex = i; // 记录原始位置
            gridIndex++;
          }
          i++;
        }
      }
      
      return gridIndex;
    }

    function distributeText() {
      try {
        const inputTextDiv = document.getElementById('input-text');
        const text = inputTextDiv.innerText; // 获取纯文本内容
        const gridContainer = document.getElementById('grid-container');
        gridContainer.innerHTML = '';
        
        // 性能优化：使用拆分后的函数
        const effectiveLength = calculateEffectiveLength(text);
        
        // 创建网格
        const numRows = Math.ceil(effectiveLength / GRID_COLUMNS_PER_ROW);
        const numItems = numRows * GRID_COLUMNS_PER_ROW;
        const fragment = createGridItems(numItems);
        gridContainer.appendChild(fragment);
        
        // 填充文本到网格
        const gridItems = document.querySelectorAll('.grid-item');
        const gridIndex = fillGridItems(text, gridItems);
        
        // 更新字数显示
        const countDisplay = document.getElementById('count-display');
        countDisplay.innerText = `表格计数: ${gridIndex}`;
        
        // 保存到撤销历史
        addToUndoHistory(text);
        
        // 隐藏之前的错误信息
        document.getElementById('error-message').style.display = 'none';
      } catch (error) {
        console.error("网格生成错误:", error);
        showError(`处理文本时发生错误: ${error.message}\n请检查特殊字符或简化文本`);
        document.getElementById('grid-container').innerHTML = '<div class="error">生成失败，请尝试简化文本</div>';
      }
    }

    // 新增：添加到撤销历史
    function addToUndoHistory(text) {
      // 只保存不同的状态
      if (undoHistory.length === 0 || undoHistory[undoHistory.length - 1] !== text) {
        undoHistory.push(text);
        
        // 限制历史记录长度
        if (undoHistory.length > MAX_UNDO_STEPS) {
          undoHistory.shift(); // 移除最早的历史记录
        }
      }
    }

    // 修改后：撤销功能中保存和恢复光标位置
    function undo() {
      try {
        if (undoHistory.length < 2) {
          showError('无法撤销：历史记录不足');
          return;
        }
        
        const inputTextDiv = document.getElementById('input-text');
        
        // 保存当前光标位置
        const caretPos = saveCaretPosition(inputTextDiv);
        
        // 移除当前状态
        undoHistory.pop();
        
        // 获取上一个状态
        const prevText = undoHistory[undoHistory.length - 1];
        
        // 更新文本框内容
        inputTextDiv.innerText = prevText;
        highlightDirectives();
        
        // 重新渲染网格
        distributeText();
        
        // 恢复光标位置
        restoreCaretPosition(inputTextDiv, caretPos);
      } catch (error) {
        showError(`撤销操作失败: ${error.message}`);
      }
    }

    function toggleAutoInput() {
      try {
        autoInputEnabled = !autoInputEnabled;
        const button = document.getElementById('toggle-auto-input');
        button.innerText = autoInputEnabled ? '自动输入·开' : '自动输入·关';
        
        // 更新按钮颜色
        if (autoInputEnabled) {
          button.classList.remove('auto-off');
          button.classList.add('auto-on');
        } else {
          button.classList.remove('auto-on');
          button.classList.add('auto-off');
        }
      } catch (error) {
        showError(`切换自动输入失败: ${error.message}`);
      }
    }

    function downloadText() {
      try {
        const text = document.getElementById('input-text').innerText;
        
        // 获取第一行文本（标题行）
        const firstLineEnd = text.indexOf('\n');
        let titleLine = firstLineEnd > -1 ? text.substring(0, firstLineEnd) : text;
        
        // 移除+N+指令并获取前25个字符
        const cleanTitle = titleLine.replace(/\+\d+\+/g, '');
        const prefix = cleanTitle.substring(0, 25).replace(/[\n\r]/g, '');
        
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        
        // 使用处理后的标题作为文件名前缀
        const fileName = `${year}${month}${day}${hours}${minutes}_${prefix}.txt`;
        
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error("下载失败:", error);
        showError(`文件下载失败: ${error.message}\n请检查浏览器权限`);
      }
    }

    // 新增：导入TXT文件功能
    function importText() {
      try {
        // 创建文件输入元素
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.txt';
        
        // 处理文件选择
        fileInput.onchange = function(event) {
          const file = event.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const content = e.target.result;
              const inputTextDiv = document.getElementById('input-text');
              
              // 保存光标位置
              const caretPos = saveCaretPosition(inputTextDiv);
              
              // 更新文本框内容
              inputTextDiv.innerText = content;
              
              // 高亮指令
              highlightDirectives();
              
              // 分发文本到网格
              distributeText();
              
              // 保存到本地存储
              saveToLocalStorage();
              
              // 恢复光标位置
              restoreCaretPosition(inputTextDiv, caretPos);
              
              // 显示成功消息
              showError(`成功导入文件: ${file.name}`);
            } catch (error) {
              showError(`导入文件失败: ${error.message}`);
            }
          };
          
          reader.onerror = function() {
            showError('读取文件失败，请检查文件格式');
          };
          
          reader.readAsText(file);
        };
        
        // 触发文件选择对话框
        fileInput.click();
      } catch (error) {
        showError(`导入功能出错: ${error.message}`);
      }
    }

    // 新增：设置光标到指定位置
    function setCaretToPosition(container, position) {
      const textNodes = getTextNodes(container);
      let total = 0;
      
      for (let node of textNodes) {
        const length = node.nodeValue.length;
        if (position >= total && position <= total + length) {
          const range = document.createRange();
          range.setStart(node, position - total);
          range.collapse(true);
          
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
          container.focus();
          
          // 添加临时高亮效果
          const highlight = document.createElement('span');
          highlight.className = 'cursor-highlight';
          highlight.appendChild(range.extractContents());
          range.insertNode(highlight);
          
          // 移除高亮效果
          setTimeout(() => {
            if (highlight.parentNode) {
              const parent = highlight.parentNode;
              while (highlight.firstChild) {
                parent.insertBefore(highlight.firstChild, highlight);
              }
              parent.removeChild(highlight);
            }
          }, 1000);
          
          return;
        }
        total += length;
      }
      
      // 如果位置超出，放在最后
      if (textNodes.length > 0) {
        const lastNode = textNodes[textNodes.length - 1];
        const range = document.createRange();
        range.setStart(lastNode, lastNode.nodeValue.length);
        range.collapse(true);
        
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        container.focus();
      }
    }

    // 新增：处理格子双击事件
    function handleGridItemDoubleClick(event) {
      const gridItem = event.target;
      if (!gridItem.classList.contains('grid-item')) return;
      
      const sourceIndex = gridItem.dataset.sourceIndex;
      if (sourceIndex === undefined) return;
      
      const inputTextDiv = document.getElementById('input-text');
      
      // 滚动页面使输入框可见
      inputTextDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // 设置光标位置
      setCaretToPosition(inputTextDiv, parseInt(sourceIndex));
      
      // 滚动输入框内部使光标位置可见
      const range = document.createRange();
      const sel = window.getSelection();
      if (sel.rangeCount > 0) {
        range.setStart(sel.anchorNode, sel.anchorOffset);
        range.collapse(true);
        range.getClientRects(); // 强制布局计算
        const rect = range.getBoundingClientRect();
        
        // 计算输入框滚动位置
        const containerRect = inputTextDiv.getBoundingClientRect();
        const scrollTop = inputTextDiv.scrollTop;
        const newScrollTop = scrollTop + (rect.top - containerRect.top) - (containerRect.height / 2);
        
        // 平滑滚动到光标位置
        inputTextDiv.scrollTo({
          top: newScrollTop,
          behavior: 'smooth'
        });
      }
    }

    window.onload = function() {
      try {
        const savedText = localStorage.getItem('savedText');
        const inputTextDiv = document.getElementById('input-text');
        
        // 设置默认文本
        const defaultText = `+5+关于Y村脱贫攻坚工作的汇报
各位领导、同事：
+2+一、整改建议。1.组织调研到"田间地头"，了解情况，走家串户查找问题。
+17+Y村村委
+15+2024年9月27日`;
        
        if (savedText) {
          inputTextDiv.innerText = savedText;
        } else {
          inputTextDiv.innerText = defaultText;
        }
        
        // 初始高亮
        highlightDirectives();
        distributeText();
        
        // 添加双击事件监听器
        document.getElementById('grid-container').addEventListener('dblclick', handleGridItemDoubleClick);
      } catch (error) {
        showError(`加载本地存储失败: ${error.message}`);
      }
    };

    function adjustTextarea(action) {
      try {
        const inputTextDiv = document.getElementById('input-text');
        const step = 20;
        const currentWidth = parseInt(window.getComputedStyle(inputTextDiv).width, 10);
        const currentHeight = parseInt(window.getComputedStyle(inputTextDiv).height, 10);
        
        if (action === 'narrow') {
          inputTextDiv.style.width = `${Math.max(100, currentWidth - step)}px`;
        } else if (action === 'wide') {
          inputTextDiv.style.width = `${currentWidth + step}px`;
        } else if (action === 'short') {
          inputTextDiv.style.height = `${Math.max(100, currentHeight - step)}px`;
        } else if (action === 'tall') {
          inputTextDiv.style.height = `${currentHeight + step}px`;
        }
      } catch (error) {
        showError(`调整文本框大小失败: ${error.message}`);
      }
    }

    function resetTextarea() {
      try {
        const inputTextDiv = document.getElementById('input-text');
        inputTextDiv.style.width = initialWidth;
        inputTextDiv.style.height = initialHeight;
      } catch (error) {
        showError(`重置文本框失败: ${error.message}`);
      }
    }

    /* 页面加载完毕后，立即填充已有文本（含本地存储恢复） */
    distributeText();
  </script>
</body>
</html>
