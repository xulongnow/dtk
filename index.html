<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  <title>在线答题卡丨申论格子纸语文作文纸</title>
  <style>
    /* 新增错误提示样式 */
    .error-message {
      color: #d9534f;
      background-color: #f2dede;
      border: 1px solid #ebccd1;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      display: none;
    }
    
    /* 打印页面全局边距，保障打印内容不裁切 */
    @page { margin: 10mm; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
    }
    .container {
      text-align: center;
      width: 100%;
      margin-top: 10px;
    }
    .guide {
      display: block;
      margin-top: 20px;
      margin-bottom: 10px;
      font-size: 16px;
    }
    @media print {
      /* 打印时隐藏不相关元素 */
      .guide, textarea, .buttons, .adjust-buttons, .error-message {
        display: none !important;
      }
      body {
        width: 100%;
        height: auto;
        /* 内部增加安全边距，兼容无@page情形 */
        padding: 10mm;
      }
      .grid-container {
        width: 100%;
        grid-template-columns: repeat(25, 1fr);
        grid-template-rows: auto;
      }
      .grid-item {
        width: auto;
        height: auto;
        padding: 1px;
        font-size: 17px;
      }
      .container { margin-top: 0; }
      
      /* 修复打印时标注被裁剪问题 */
  .grid-item:nth-child(100n)::after {
    right: 0;
    font-size: 8px; /* 进一步缩小打印字体 */
    bottom: -10px;
    transform: translateX(100%);
    padding-right: 1px;
    max-width: 18px; /* 更严格的打印限制 */
  }
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(25, auto);
      column-gap: 0;
      row-gap: 8px;
      justify-content: center;
      margin-top: 20px;
    }
    .grid-item {
      border-top: 1px solid red;
      border-left: 1px solid red;
      border-bottom: 1px solid red;
      padding: 5px;
      text-align: center;
      font-size: 20px;
      width: 1.1em;
      height: 1.1em;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .grid-item:nth-child(25n) { border-right: 1px solid red; }
    .grid-item:nth-child(100n) {
      border-right: 2px solid red;
      position: relative;
    }
/* 修改后（普通模式） */
.grid-item:nth-child(100n)::after {
  content: attr(data-index);
  color: red;
  font-size: 10px; /* 缩小字体避免溢出 */
  font-weight: normal;
  position: absolute;
  right: 0; /* 对齐格子右边线 */
  bottom: -12px; /* 下移避免重叠 */
  transform: translateX(100%); /* 数字整体右移 */
  padding-right: 2px; /* 添加微调间距 */
  text-align: right; /* 文本右对齐 */
  width: max-content; /* 自适应宽度 */
  max-width: 22px; /* 限制最大宽度 */
  overflow: hidden; /* 防溢出 */
}
    textarea {
      width: 40%;
      height: 250px;
      margin-bottom: 10px;
      font-size: 18px;
    }
    .buttons {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .buttons button { margin: 0 10px; }
    .count-display {
      margin-left: 10px;
      font-size: 14px;
      font-weight: bold;
      padding: 5px;
      border: 1px solid #000;
      border-radius: 5px;
      background-color: #f0f0f0;
    }
    .input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .size-buttons {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }
    .size-buttons button { margin: 0 5px; }
    
    /* 移动端适配 */
    @media (max-width: 768px) {
      textarea { width: 90%; }
      .grid-item { font-size: 16px; }
      .buttons { flex-wrap: wrap; }
      .buttons button { margin: 5px; }
    }
  </style>
</head>
<body>
  <div class="guide">仅用于考试答题模拟，无在线缓存功能，请及时保存</div>
  <div class="guide">【回车键】换行（自动空2格）、【空格键】空1格、【Tab键】空2格、【+N+】空N格</div>
  <div class="error-message" id="error-message"></div>
  <div class="container">
    <div class="input-container">
      <div class="size-buttons adjust-buttons">
        <button onclick="resetTextarea()">复原</button>
        <button onclick="adjustTextarea('wide')">宽</button>
        <button onclick="adjustTextarea('narrow')">窄</button>
        <button onclick="adjustTextarea('tall')">高</button>
        <button onclick="adjustTextarea('short')">低</button>
      </div>
      <textarea id="input-text" oninput="distributeTextWithDelay()" onkeydown="handleKeyDown(event)">+5+关于Y村脱贫攻坚工作的汇报
各位领导、同事：
+2+一、整改建议。1.组织调研到"田间地头"，了解情况，走家串户查找问题。
+17+Y村村委
+15+2024年9月27日</textarea>
    </div>
    <div class="buttons">
      <button onclick="clearPlusN()">清除+N+</button>
      <button onclick="clearNewLines()">清除换行</button>
      <button onclick="clearSpaces()">清除空格</button>
      <button onclick="clearInput()">清空</button>
      <button id="toggle-auto-input" onclick="toggleAutoInput()">自动输入·开</button>
      <button onclick="distributeText()">填入答题纸</button>
      <button onclick="downloadText()">下载TXT</button>
      <button onclick="window.print()">打印</button>
      <div class="count-display" id="count-display">统计字数: 0</div>
    </div>
    <div class="grid-container" id="grid-container"></div>
  </div>
  <script>
    const GRID_COLUMNS_PER_ROW = 25;
    let updateTimeout;
    let autoInputEnabled = true;
    const initialWidth = '40%';
    const initialHeight = '250px';

    // 新增：错误消息显示函数
    function showError(message) {
      const errorElement = document.getElementById('error-message');
      errorElement.innerText = message;
      errorElement.style.display = 'block';
      
      // 5秒后自动隐藏错误信息
      setTimeout(() => {
        errorElement.style.display = 'none';
      }, 5000);
    }

    function insertText(text) {
      try {
        const textarea = document.getElementById('input-text');
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const value = textarea.value;
        textarea.value = value.slice(0, start) + text + value.slice(end);
        textarea.selectionStart = textarea.selectionEnd = start + text.length;
        textarea.focus();
      } catch (error) {
        showError(`插入文本失败: ${error.message}`);
      }
    }

    function handleKeyDown(event) {
      try {
        if (event.key === 'Enter') {
          event.preventDefault();
          // 修改：回车时自动添加换行符和+2+指令
          insertText('\n+2+');
          distributeTextWithDelay();
        } else if (event.key === 'Tab') {
          event.preventDefault();
          insertText('+2+');
          distributeTextWithDelay();
        } else if (event.key === ' ') {
          event.preventDefault();
          insertText(' ');
          distributeTextWithDelay();
        }
      } catch (error) {
        showError(`按键处理错误: ${error.message}`);
      }
    }

    function clearNewLines() {
      try {
        const textarea = document.getElementById('input-text');
        textarea.value = textarea.value.replace(/\n/g, '');
        distributeTextWithDelay();
      } catch (error) {
        showError(`清除换行失败: ${error.message}`);
      }
    }

    function clearSpaces() {
      try {
        const textarea = document.getElementById('input-text');
        textarea.value = textarea.value.replace(/ /g, '');
        distributeTextWithDelay();
      } catch (error) {
        showError(`清除空格失败: ${error.message}`);
      }
    }

    function clearInput() {
      try {
        const textarea = document.getElementById('input-text');
        textarea.value = '';
        distributeTextWithDelay();
      } catch (error) {
        showError(`清空输入失败: ${error.message}`);
      }
    }

    function clearPlusN() {
      try {
        const textarea = document.getElementById('input-text');
        textarea.value = textarea.value.replace(/\+\d+\+/g, '');
        distributeTextWithDelay();
      } catch (error) {
        showError(`清除+N+指令失败: ${error.message}`);
      }
    }
    
    function distributeTextWithDelay() {
      clearTimeout(updateTimeout);
      if (!autoInputEnabled) return;
      
      // 性能优化：减少DOM操作频率
      updateTimeout = setTimeout(() => {
        try {
          distributeText();
          saveToLocalStorage();
        } catch (error) {
          showError(`文本处理失败: ${error.message}`);
        }
      }, 300); // 延迟时间从500ms减少到300ms
    }

    function saveToLocalStorage() {
      try {
        const text = document.getElementById('input-text').value;
        localStorage.setItem('savedText', text);
      } catch (error) {
        showError(`保存到本地存储失败: ${error.message}`);
      }
    }

    // 性能优化：拆分大型函数
    function calculateEffectiveLength(text) {
      let effectiveLength = 0;
      
      for (let i = 0; i < text.length; i++) {
        if (text[i] === '\n') {
          effectiveLength += GRID_COLUMNS_PER_ROW - (effectiveLength % GRID_COLUMNS_PER_ROW);
        } else if (text[i] === '+') {
          if (/\d/.test(text[i + 1])) {
            let j = i + 1;
            let validDirective = true;
            while (j < text.length && text[j] !== '+') {
              if (!/\d/.test(text[j])) {
                validDirective = false;
                break;
              }
              j++;
            }
            if (validDirective && j < text.length && text[j] === '+') {
              effectiveLength += parseInt(text.substring(i + 1, j), 10);
              i = j;
            } else {
              effectiveLength++;
            }
          } else {
            effectiveLength++;
          }
        } else {
          effectiveLength++;
        }
      }
      
      return effectiveLength;
    }

    function createGridItems(numItems) {
      const fragment = document.createDocumentFragment();
      
      for (let i = 0; i < numItems; i++) {
        const gridItem = document.createElement('div');
        gridItem.className = 'grid-item';
        if ((i + 1) % 100 === 0) {
          gridItem.setAttribute('data-index', i + 1);
        }
        fragment.appendChild(gridItem);
      }
      
      return fragment;
    }

    function fillGridItems(text, gridItems) {
      let gridIndex = 0;
      let i = 0;
      
      while (i < text.length && gridIndex < gridItems.length) {
        if (text[i] === '\n') {
          if (gridIndex % GRID_COLUMNS_PER_ROW !== 0) {
            gridIndex = Math.floor(gridIndex / GRID_COLUMNS_PER_ROW) * GRID_COLUMNS_PER_ROW + GRID_COLUMNS_PER_ROW;
          }
          i++;
        } else if (/[a-zA-Z0-9]/.test(text[i]) && /[a-zA-Z0-9.]/.test(text[i + 1])) {
          gridItems[gridIndex].innerText = text.substring(i, i + 2);
          gridIndex++;
          i += 2;
        } else if (text[i] === '+') {
          if (/\d/.test(text[i + 1])) {
            let j = i + 1;
            let validDirective = true;
            while (j < text.length && text[j] !== '+') {
              if (!/\d/.test(text[j])) {
                validDirective = false;
                break;
              }
              j++;
            }
            if (validDirective && j < text.length && text[j] === '+') {
              const numSpaces = parseInt(text.substring(i + 1, j), 10);
              for (let k = 0; k < numSpaces && gridIndex < gridItems.length; k++) {
                gridItems[gridIndex].innerText = ' ';
                gridIndex++;
              }
              i = j + 1;
            } else {
              gridItems[gridIndex].innerText = text[i];
              gridIndex++;
              i++;
            }
          } else {
            gridItems[gridIndex].innerText = text[i];
            gridIndex++;
            i++;
          }
        } else {
          // 行首标点避头，排除省略号和破折号
          if (gridIndex % GRID_COLUMNS_PER_ROW === 0 
              && /[，。！？；：’”、）》,.!?;:]/.test(text[i]) 
              && text[i] !== '…' && text[i] !== '—') {
            gridItems[gridIndex - 1].innerText += text[i];
          }
          // 引号后标点合并，同样排除省略号和破折号
          else if (gridIndex > 0 
              && /[》”"]/.test(gridItems[gridIndex - 1].innerText) 
              && /[、，。：；？！,.?!;:]/.test(text[i]) 
              && text[i] !== '…' && text[i] !== '—') {
            gridItems[gridIndex - 1].innerText += text[i];
          }
          else {
            gridItems[gridIndex].innerText = text[i];
            gridIndex++;
          }
          i++;
        }
      }
      
      return gridIndex;
    }

    function distributeText() {
      try {
        const text = document.getElementById('input-text').value;
        const gridContainer = document.getElementById('grid-container');
        gridContainer.innerHTML = '';
        
        // 性能优化：使用拆分后的函数
        const effectiveLength = calculateEffectiveLength(text);
        
        // 创建网格
        const numRows = Math.ceil(effectiveLength / GRID_COLUMNS_PER_ROW);
        const numItems = numRows * GRID_COLUMNS_PER_ROW;
        const fragment = createGridItems(numItems);
        gridContainer.appendChild(fragment);
        
        // 填充文本到网格
        const gridItems = document.querySelectorAll('.grid-item');
        const gridIndex = fillGridItems(text, gridItems);
        
        // 更新字数显示
        const countDisplay = document.getElementById('count-display');
        countDisplay.innerText = `表格计数: ${gridIndex}`;
        
        // 隐藏之前的错误信息
        document.getElementById('error-message').style.display = 'none';
      } catch (error) {
        console.error("网格生成错误:", error);
        showError(`处理文本时发生错误: ${error.message}\n请检查特殊字符或简化文本`);
        document.getElementById('grid-container').innerHTML = '<div class="error">生成失败，请尝试简化文本</div>';
      }
    }

    function toggleAutoInput() {
      try {
        autoInputEnabled = !autoInputEnabled;
        const button = document.getElementById('toggle-auto-input');
        button.innerText = autoInputEnabled ? '自动输入·开' : '自动输入·关';
        alert(`已切换为 ${button.innerText}`);
      } catch (error) {
        showError(`切换自动输入失败: ${error.message}`);
      }
    }

    function downloadText() {
      try {
        const text = document.getElementById('input-text').value;
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const prefix = text.substring(0, 8);
        const fileName = `${year}${month}${day}${hours}${minutes}_${prefix}.txt`;
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error("下载失败:", error);
        showError(`文件下载失败: ${error.message}\n请检查浏览器权限`);
      }
    }

    window.onload = function() {
      try {
        const savedText = localStorage.getItem('savedText');
        if (savedText) {
          document.getElementById('input-text').value = savedText;
          distributeText();
        }
      } catch (error) {
        showError(`加载本地存储失败: ${error.message}`);
      }
    };

    function adjustTextarea(action) {
      try {
        const textarea = document.getElementById('input-text');
        const step = 20;
        const currentWidth = parseInt(window.getComputedStyle(textarea).width, 10);
        const currentHeight = parseInt(window.getComputedStyle(textarea).height, 10);
        
        if (action === 'narrow') {
          textarea.style.width = `${Math.max(100, currentWidth - step)}px`;
        } else if (action === 'wide') {
          textarea.style.width = `${currentWidth + step}px`;
        } else if (action === 'short') {
          textarea.style.height = `${Math.max(100, currentHeight - step)}px`;
        } else if (action === 'tall') {
          textarea.style.height = `${currentHeight + step}px`;
        }
      } catch (error) {
        showError(`调整文本框大小失败: ${error.message}`);
      }
    }

    function resetTextarea() {
      try {
        const textarea = document.getElementById('input-text');
        textarea.style.width = initialWidth;
        textarea.style.height = initialHeight;
      } catch (error) {
        showError(`重置文本框失败: ${error.message}`);
      }
    }

    /* 页面加载完毕后，立即填充已有文本（含本地存储恢复） */
    distributeText();
  </script>
</body>
</html>